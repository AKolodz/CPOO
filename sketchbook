

# median = cv2.medianBlur(original, 11)
# cv2.namedWindow("Median", cv2.WINDOW_NORMAL)
# cv2.imshow("Median", median)


# binary = cv2.adaptiveThreshold(median, 255, cv2.ADAPTIVE_THRESH_MEAN_C, cv2.THRESH_BINARY, 11, 2)
# cv2.namedWindow("Binary", cv2.WINDOW_NORMAL)
# cv2.imshow("Binary", binary)


# lines = cv2.HoughLines(edges, 1, np.pi / 200, 200)
# for i in range(0, len(lines)):
#     for rho, theta in lines[i]:
#         a = np.cos(theta)
#         b = np.sin(theta)
#         x0 = a * rho
#         y0 = b * rho
#         x1 = int(x0 + 1000 * (-b))
#         y1 = int(y0 + 1000 * (a))
#         x2 = int(x0 - 1000 * (-b))
#         y2 = int(y0 - 1000 * (a))
#         cv2.line(small, (x1, y1), (x2, y2), (0, 0, 255), 2)

https://docs.opencv.org/3.2.0/da/d6e/tutorial_py_geometric_transformations.html
# pts1 = np.float32([[112, 156], [112, 706], [663, 154], [665, 704]])
# pts2 = np.float32([[0, 0], [0, 300], [300, 0], [300, 300]])
# M = cv2.getPerspectiveTransform(pts1, pts2)
# perspective = cv2.warpPerspective(colored, M, (300, 300))

# Cut
# leftUpperCornerPoint = getPoint(rotatedImage)
# rightBottomCornerPoint = getPoint(rotatedImage)
# p1 = leftUpperCornerPoint
# # p2 = rightBottomCornerPoint", cv2.WINDOW_NORMAL)
# p1 = (448, 608)
# p2 = (662 * 4, 705 * 4)
# phantomImage = ImageCutter.cut(noisedImage, p1, p2)
# cv2.namedWindow("ROI", cv2.WINDOW_NORMAL)
# cv2.imshow("ROI", phantomImage)

# cv2.namedWindow("Aligned", cv2.WINDOW_NORMAL)
# cv2.imshow("Aligned", alignedImage)
# ref_roi = alignedImage[900:1000, 1480:1560]
# ref_mean = ref_roi.mean()
# # alignedImage[y1:y2, x1:x2]
# alignedImage = alignedImage[603:1630, 1560:1730]
# alignedImage = cv2.resize(alignedImage, (0, 0), fx=0.5, fy=0.5)
# alignedImage = cv2.medianBlur(alignedImage, 7)
# alignedImage = cv2.equalizeHist(alignedImage)
# cv2.imshow("equalizeHist", alignedImage)
# edges = cv2.Canny(alignedImage, 150, 140, None, 3)
# cv2.imshow("Edges", edges)
# th3 = cv2.adaptiveThreshold(edges, 255, cv2.ADAPTIVE_THRESH_GAUSSIAN_C, \
#                             cv2.THRESH_BINARY, 13, 4)
# cv2.imshow("segm", th3)
#
# circles = cv2.HoughCircles(th3, cv2.HOUGH_GRADIENT, 1, 20,
#                            param1=50, param2=30, minRadius=20, maxRadius=50)
#
# circles = np.uint16(np.around(circles))
# # for i in circles[0, :]:
# #     # draw the outer circle
# #     cv2.circle(alignedImage, (i[0], i[1]), i[2], (0, 255, 0), 2)
# #     # draw the center of the circle
# #     cv2.circle(alignedImage, (i[0], i[1]), 2, (0, 0, 255), 3)
# # cv2.imshow('detected circles ph', alignedImage)
# for i in range(2):
#     cv2.circle(alignedImage, (circles[0, 0, 0], circles[0, i, 1]), circles[0, 0, 2], (0, 255, 0), 2)
#     cv2.circle(alignedImage, (circles[0, 0, 0], circles[0, i, 1]), 2, (0, 0, 255), 3)
#
# circle3 = alignedImage[194:214, 34:54]
# circle4 = alignedImage[280:300, 34:54]
# circle5 = alignedImage[366:386, 34:54]
# circle6 = alignedImage[452:472, 34:54]
# if circle3.mean() > 1.5 * ref_mean:
#     cv2.circle(alignedImage, (circles[0, 0, 0], 204), circles[0, 0, 2], (0, 255, 0), 2)
#     cv2.circle(alignedImage, (circles[0, 0, 0], 204), 2, (0, 0, 255), 3)
#
# if circle4.mean() > 1.5 * ref_mean:
#     cv2.circle(alignedImage, (circles[0, 0, 0], 290), circles[0, 0, 2], (0, 255, 0), 2)
#     cv2.circle(alignedImage, (circles[0, 0, 0], 290), 2, (0, 0, 255), 3)
#
# if circle5.mean() > 1.5 * ref_mean:
#     cv2.circle(alignedImage, (circles[0, 0, 0], 376), circles[0, 0, 2], (0, 255, 0), 2)
#     cv2.circle(alignedImage, (circles[0, 0, 0], 376), 2, (0, 0, 255), 3)
#
# if circle6.mean() > 1.5 * ref_mean:
#     cv2.circle(alignedImage, (circles[0, 0, 0], 462), circles[0, 0, 2], (0, 255, 0), 2)
#     cv2.circle(alignedImage, (circles[0, 0, 0], 462), 2, (0, 0, 255), 3)
#
# cv2.imshow('detected circles ph', alignedImage)

